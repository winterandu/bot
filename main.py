import discord
from discord.ext import commands
from discord import PCMVolumeTransformer
import yt_dlp
from yt_dlp import *
import re
import spotipy
from spotipy.oauth2 import SpotifyClientCredentials
from gtts import gTTS
from collections import deque
import asyncio
import os
import math
from dotenv import load_dotenv

# Load environment variables t·ª´ file .env
load_dotenv()

intents = discord.Intents.default()
intents.message_content = True
intents.voice_states = True
intents.reactions = True  # Th√™m quy·ªÅn reactions

# L·∫•y bot prefix t·ª´ .env ho·∫∑c d√πng default
BOT_PREFIX = os.getenv('BOT_PREFIX', '`')
bot = commands.Bot(command_prefix=BOT_PREFIX, intents=intents, help_command=None)  # T·∫Øt help m·∫∑c ƒë·ªãnh

# L·∫•y Spotify credentials t·ª´ environment variables
SPOTIFY_CLIENT_ID = os.getenv('SPOTIFY_CLIENT_ID')
SPOTIFY_CLIENT_SECRET = os.getenv('SPOTIFY_CLIENT_SECRET')

# Kh·ªüi t·∫°o Spotify client n·∫øu credentials c√≥ s·∫µn
spotify = None
if SPOTIFY_CLIENT_ID and SPOTIFY_CLIENT_SECRET:
    try:
        auth_manager = SpotifyClientCredentials(
            client_id=SPOTIFY_CLIENT_ID,
            client_secret=SPOTIFY_CLIENT_SECRET
        )
        spotify = spotipy.Spotify(auth_manager=auth_manager)
        print("‚úÖ Spotify client ƒë√£ ƒë∆∞·ª£c kh·ªüi t·∫°o")
    except Exception as e:
        print(f"‚ö†Ô∏è Kh√¥ng th·ªÉ kh·ªüi t·∫°o Spotify client: {e}")
        spotify = None
else:
    print("‚ö†Ô∏è Spotify credentials kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong .env file")

def test_spotify_connection():
    """Ki·ªÉm tra k·∫øt n·ªëi Spotify API"""
    if not spotify:
        print("‚ùå Spotify client ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o")
        return False
        
    try:
        # Th·ª≠ l·∫•y th√¥ng tin m·ªôt track test
        spotify.track('4iV5W9uYEdYUVa79Axb7Rh')  # Never Gonna Give You Up :)
        print("‚úÖ Spotify API k·∫øt n·ªëi th√†nh c√¥ng")
        return True
    except Exception as e:
        print(f"‚ùå L·ªói k·∫øt n·ªëi Spotify API: {e}")
        return False

# C·∫•u h√¨nh yt-dlp
YDL_OPTIONS = {
    "format": "bestaudio[ext=mp3]/bestaudio/best",
    "noplaylist": True,
    "quiet": True,
    "extract_flat": False,
    "source_address": "0.0.0.0",
    "default_search": "ytsearch:",  # T·ª± ƒë·ªông t√¨m ki·∫øm tr√™n YouTube
    "no_warnings": True,
}

FFMPEG_OPTIONS = {
    "before_options": "-re -reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5",
    "options": "-vn",
}


# Bi·∫øn to√†n c·ª•c
queue = deque()
is_playing = False
is_looping = False
current_song = None
current_song_info = None  # Th√™m bi·∫øn ƒë·ªÉ l∆∞u th√¥ng tin chi ti·∫øt b√†i h√°t
force_skip = False
volume_level = 0.5
current_player = None

# Cache ƒë·ªÉ l∆∞u t√™n b√†i h√°t
song_title_cache = {}  # {query: title}

def format_duration(duration: float) -> str:
    """ƒê·ªãnh d·∫°ng th·ªùi l∆∞·ª£ng t·ª´ gi√¢y sang ph√∫t:gi√¢y"""
    if duration <= 0:
        return "Live"
    
    minutes = int(duration // 60)
    seconds = int(round(duration % 60))
    return f"{minutes}:{seconds:02d}"

async def get_song_title_from_query(query):
    """L·∫•y t√™n b√†i h√°t t·ª´ query ƒë·ªÉ hi·ªÉn th·ªã"""
    try:
        # N·∫øu l√† URL, th·ª≠ l·∫•y th√¥ng tin
        if "youtube.com" in query or "youtu.be" in query or "soundcloud.com" in query:
            audio_info = await get_audio_info(query)
            if audio_info:
                return audio_info['title']
        
        # N·∫øu kh√¥ng ph·∫£i URL, tr·∫£ v·ªÅ query g·ªëc
        return query
    except:
        return query

async def get_display_title(query, use_cache=True):
    """L·∫•y t√™n hi·ªÉn th·ªã cho b√†i h√°t v·ªõi cache ƒë·ªÉ tƒÉng t·ªëc ƒë·ªô"""
    global song_title_cache
    
    # Ki·ªÉm tra cache tr∆∞·ªõc
    if use_cache and query in song_title_cache:
        return song_title_cache[query]
    
    try:
        # X·ª≠ l√Ω Spotify URL tr∆∞·ªõc
        processed_query = query
        if "open.spotify.com/track" in query or "spotify:track:" in query:
            spotify_query = await process_spotify_track(query)
            if spotify_query:
                processed_query = spotify_query
        
        # X·ª≠ l√Ω SoundCloud URL
        elif "soundcloud.com" in query:
            soundcloud_url = await process_soundcloud_track(query)
            if soundcloud_url:
                processed_query = soundcloud_url
        
        # N·∫øu l√† URL, l·∫•y th√¥ng tin chi ti·∫øt
        if ("youtube.com" in processed_query or "youtu.be" in processed_query or 
            "soundcloud.com" in processed_query):
            audio_info = await get_audio_info(processed_query)
            if audio_info and audio_info.get('title'):
                title = audio_info['title']
                # L∆∞u v√†o cache
                song_title_cache[query] = title
                return title
        
        # Fallback v·ªÅ query g·ªëc
        display_title = query[:60] + ('...' if len(query) > 60 else '')
        song_title_cache[query] = display_title
        return display_title
        
    except Exception as e:
        # N·∫øu c√≥ l·ªói, s·ª≠ d·ª•ng query g·ªëc
        display_title = query[:60] + ('...' if len(query) > 60 else '')
        song_title_cache[query] = display_title
        return display_title

@bot.event
async def on_ready():
    print(f'‚úÖ Bot ƒëang ch·∫°y: {bot.user}')
    await bot.change_presence(activity=discord.Activity(type=discord.ActivityType.listening, name="`help"))

@bot.command()
async def help(ctx):
    """Hi·ªán b·∫£ng help"""
    embed = discord.Embed(
        title="üìã Danh s√°ch l·ªánh bot nh·∫°c",
        description="D∆∞·ªõi ƒë√¢y l√† t·∫•t c·∫£ c√°c l·ªánh c√≥ s·∫µn:",
        color=discord.Color.blue()
    )
    
    commands_list = [
        "**play** - Ph√°t nh·∫°c t·ª´ YouTube, SoundCloud ho·∫∑c Spotify(Spotify s·∫Ω b·ªã delay)",
        "**loop** - B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i b√†i h√°t hi·ªán t·∫°i",
        "**pause** - T·∫°m d·ª´ng ph√°t nh·∫°c",
        "**resume** - Ti·∫øp t·ª•c ph√°t nh·∫°c",
        "**skip** - B·ªè qua b√†i h√°t hi·ªán t·∫°i",
        "**stop** - D·ª´ng ph√°t nh·∫°c v√† x√≥a h√†ng ch·ªù",
        "**now** - Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t",
        "**queue** - Hi·ªÉn th·ªã danh s√°ch h√†ng ch·ªù - S·ª≠ d·ª•ng: queue [s·ªë_trang]",
        "**queuenext** - Chuy·ªÉn sang trang ti·∫øp theo c·ªßa h√†ng ch·ªù",
        "**queueprev** - Chuy·ªÉn v·ªÅ trang ƒë·∫ßu c·ªßa h√†ng ch·ªù",
        "**volume** - ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng (0.0-2.0)",
        "**leave** - R·ªùi kh·ªèi voice channel",
        "**speak** - ƒê·ªçc vƒÉn b·∫£n b·∫±ng gi·ªçng n√≥i",
    ]
    
    embed.add_field(
        name="C√°c l·ªánh ch√≠nh",
        value="\n".join(commands_list),
        inline=False
    )
    
    # Th√™m th√¥ng tin v·ªÅ aliases
    embed.add_field(
        name="‚ö° L·ªánh t·∫Øt",
        value="```‚èØÔ∏è p = play\n‚è≠Ô∏è n = skip\n‚èπÔ∏è s = stop\nüìÉ q = queue```",
        inline=True
    )
    
    
    embed.set_footer(
        text=f"S·ª≠ d·ª•ng {BOT_PREFIX}<l·ªánh> ƒë·ªÉ th·ª±c hi·ªán | Bot ƒë∆∞·ª£c t·∫°o b·ªüi Laam.",
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None
    )
    
    embed.timestamp = ctx.message.created_at
    
    await ctx.send(embed=embed)


@bot.command()
async def leave(ctx):
    """R·ªùi kh·ªèi voice channel"""
    if ctx.voice_client:
        queue.clear()
        await ctx.voice_client.disconnect()
        await ctx.send("‚úÖ ƒê√£ r·ªùi kh·ªèi voice channel")
    else:
        await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel")

async def process_spotify_track(url):
    """X·ª≠ l√Ω Spotify track"""
    if not spotify:
        print("‚ùå Spotify client kh√¥ng c√≥ s·∫µn")
        return None
        
    try:
        # T√¨m track ID t·ª´ nhi·ªÅu ƒë·ªãnh d·∫°ng URL kh√°c nhau
        track_id_patterns = [
            r'track/([a-zA-Z0-9]+)',  # URL th√¥ng th∆∞·ªùng
            r'spotify:track:([a-zA-Z0-9]+)',  # URI format
        ]
        
        track_id = None
        for pattern in track_id_patterns:
            match = re.search(pattern, url)
            if match:
                track_id = match.group(1)
                break
        
        if not track_id:
            print(f"Kh√¥ng t√¨m th·∫•y track ID trong URL: {url}")
            return None
            
        # L·∫•y th√¥ng tin track t·ª´ Spotify API
        track = spotify.track(track_id)
        
        # T·∫°o query t√¨m ki·∫øm t·ªëi ∆∞u cho YouTube
        artists = [artist['name'] for artist in track['artists']]
        artist_str = ', '.join(artists)
        
        # Th·ª≠ nhi·ªÅu format t√¨m ki·∫øm
        search_queries = [
            f"{track['name']} {artist_str}",
            f"{track['name']} - {artist_str} official audio",
            f"{track['name']} {artist_str} lyrics",
            f"{artist_str} - {track['name']}"
        ]
        
        print(f"Spotify track: {track['name']} by {artist_str}")
        return search_queries[0]  # S·ª≠ d·ª•ng query ƒë·∫ßu ti√™n
        
    except spotipy.exceptions.SpotifyException as e:
        print(f"Spotify API error: {e}")
        return None
    except Exception as e:
        print(f"Spotify processing error: {e}")
        return None

async def process_soundcloud_track(url):
    """X·ª≠ l√Ω SoundCloud track"""
    try:
        clean_url = url.split('?')[0]
        return clean_url
    except:
        return None

async def get_audio_info(query):
    """L·∫•y th√¥ng tin audio t·ª´ yt-dlp"""
    try:
        with yt_dlp.YoutubeDL(YDL_OPTIONS) as ydl:
            info = ydl.extract_info(query, download=False)
            
            if not info:
                return None
                
            if 'entries' in info:
                info = info['entries'][0]
                
            return {
                'url': info['url'],
                'title': info.get('title', 'Kh√¥ng r√µ ti√™u ƒë·ªÅ'),
                'duration': info.get('duration', 0),
                'webpage_url': info.get('webpage_url', query),
                'thumbnail': info.get('thumbnail', None)
            }
    except Exception as e:
        print(f"Error getting audio info: {e}")
        return None

async def play_next():
    global is_playing, current_song, force_skip, current_player, current_song_info
    
    if not queue:
        is_playing = False
        current_song_info = None
        return
        
    is_playing = True
    ctx, query = queue.popleft()
    current_song = (ctx, query)
    vc = ctx.voice_client
    
    if not vc:
        await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel")
        is_playing = False
        return
    
    # Hi·ªÉn th·ªã th√¥ng b√°o "ƒêang chu·∫©n b·ªã" ngay l·∫≠p t·ª©c
    preparing_msg = await ctx.send("‚èØÔ∏è **ƒêang chu·∫©n b·ªã ph√°t nh·∫°c...**")
    
    # X·ª≠ l√Ω Spotify URL
    if "open.spotify.com/track" in query or "spotify:track:" in query:
        await preparing_msg.edit(content="‚èØÔ∏è ƒêang x·ª≠ l√Ω link Spotify...")
        spotify_query = await process_spotify_track(query)
        if spotify_query:
            query = spotify_query
            await preparing_msg.edit(content=f"‚úÖ ƒê√£ t√¨m th·∫•y b√†i h√°t t·ª´ Spotify: `{query[:50]}...`")
        else:
            await preparing_msg.edit(content="‚ùå Kh√¥ng th·ªÉ x·ª≠ l√Ω link Spotify n√†y. Vui l√≤ng ki·ªÉm tra l·∫°i link ho·∫∑c th·ª≠ link kh√°c.")
            return await play_next()
    
    # X·ª≠ l√Ω SoundCloud URL
    elif "soundcloud.com" in query:
        await preparing_msg.edit(content="‚èØÔ∏è ƒêang x·ª≠ l√Ω link SoundCloud...")
        soundcloud_url = await process_soundcloud_track(query)
        if soundcloud_url:
            query = soundcloud_url
        else:
            await preparing_msg.edit(content="‚ùå Kh√¥ng th·ªÉ x·ª≠ l√Ω link SoundCloud n√†y")
            return await play_next()
    
    # C·∫≠p nh·∫≠t th√¥ng b√°o ƒëang t·∫£i
    await preparing_msg.edit(content="üîÑ **ƒêang t·∫£i nh·∫°c...**")
    
    # L·∫•y th√¥ng tin audio
    audio_info = await get_audio_info(query)
    if not audio_info:
        await preparing_msg.edit(content=f"‚ùå Kh√¥ng t√¨m th·∫•y b√†i h√°t: `{query}`")
        return await play_next()
    
    # L∆∞u th√¥ng tin chi ti·∫øt b√†i h√°t hi·ªán t·∫°i
    current_song_info = audio_info
    
    # T·∫°o audio source
    try:
        audio_source = discord.FFmpegPCMAudio(
            audio_info['url'],
            **FFMPEG_OPTIONS
        )
    except Exception as e:
        await preparing_msg.edit(content=f"‚ùå L·ªói khi t·∫°o ngu·ªìn √¢m thanh: {e}")
        return await play_next()
    
    def after_playing(error):
        if error:
            print(f"Playback error: {error}")
        
        coro = replay_current() if is_looping else play_next()
        future = asyncio.run_coroutine_threadsafe(coro, bot.loop)
        try:
            future.result()
        except Exception as e:
            print(f"Error in after_playing: {e}")
    
    try:
        current_player = PCMVolumeTransformer(audio_source, volume=volume_level)
        vc.play(current_player, after=after_playing)
        
        # Hi·ªÉn th·ªã th√¥ng tin b√†i h√°t ngay khi b·∫Øt ƒë·∫ßu ph√°t
        duration_str = format_duration(audio_info['duration'])
        
        embed = discord.Embed(
            title="üé∂ ƒêang ph√°t",
            description=f"[{audio_info['title']}]({audio_info['webpage_url']})",
            color=discord.Color.blue()
        )
        embed.add_field(name="‚è≥ Th·ªùi l∆∞·ª£ng", value=duration_str)
        embed.set_footer(text=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name}", icon_url=ctx.author.avatar.url)
        
        # C·∫≠p nh·∫≠t th√¥ng b√°o chu·∫©n b·ªã th√†nh th√¥ng b√°o ƒëang ph√°t
        await preparing_msg.edit(content="", embed=embed)
        
    except Exception as e:
        await preparing_msg.edit(content=f"‚ùå L·ªói khi ph√°t nh·∫°c: {e}")
        return await play_next()

async def replay_current():
    global current_song
    if current_song:
        queue.appendleft(current_song)
        await play_next()

async def show_added_track(ctx, query):
    """Hi·ªÉn th·ªã th√¥ng b√°o b√†i h√°t ƒë√£ ƒë∆∞·ª£c th√™m v√†o h√†ng ch·ªù v·ªõi t√™n b√†i h√°t th·ª±c"""
    # T√≠nh to√°n v·ªã tr√≠ trong h√†ng ch·ªù
    queue_position = len(queue)
    
    # L·∫•y t√™n b√†i h√°t th·ª±c t·∫ø v√† l∆∞u v√†o cache
    try:
        song_title = await get_display_title(query, use_cache=True)
    except Exception as e:
        # N·∫øu c√≥ l·ªói, s·ª≠ d·ª•ng query g·ªëc
        song_title = query[:60] + ('...' if len(query) > 60 else '')
    
    embed = discord.Embed(
        title="‚úÖ ƒê√£ th√™m v√†o h√†ng ch·ªù",
        description=f"‚èØÔ∏è `{song_title}`",
        color=discord.Color.green()
    )
    
    embed.add_field(
        name="üìç V·ªã tr√≠", 
        value=f"#{queue_position}", 
        inline=True
    )
    

    
    embed.set_footer(
        text=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name}", 
        icon_url=ctx.author.avatar.url if ctx.author.avatar else None
    )
    
    await ctx.send(embed=embed)
    

@bot.command(aliases=['p'])
async def play(ctx, *, query):
    """Ph√°t nh·∫°c t·ª´ YouTube, SoundCloud ho·∫∑c Spotify"""
    if not ctx.author.voice:
        return await ctx.send("‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc.")
    
    vc = ctx.voice_client
    if not vc:
        vc = await ctx.author.voice.channel.connect()
    
    # Th√™m v√†o h√†ng ch·ªù
    queue.append((ctx, query))
    
    # Ch·ªâ hi·ªÉn th·ªã th√¥ng b√°o "ƒë√£ th√™m v√†o h√†ng ch·ªù" n·∫øu ƒëang c√≥ b√†i kh√°c ph√°t
    if is_playing:
        await show_added_track(ctx, query)
    
    # Ch·∫°y play_next() trong background n·∫øu kh√¥ng c√≥ b√†i n√†o ƒëang ph√°t
    if not is_playing:
        # T·∫°o task ƒë·ªÉ ch·∫°y song song, kh√¥ng ch·ªù ƒë·ª£i
        asyncio.create_task(play_next())

@bot.command()
async def pause(ctx):
    """T·∫°m d·ª´ng ph√°t nh·∫°c"""
    if ctx.voice_client and ctx.voice_client.is_playing():
        ctx.voice_client.pause()
        await ctx.send("‚è∏Ô∏è ƒê√£ t·∫°m d·ª´ng.")
    else:
        await ctx.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.")

@bot.command()
async def resume(ctx):
    """Ti·∫øp t·ª•c ph√°t nh·∫°c"""
    if ctx.voice_client and ctx.voice_client.is_paused():
        ctx.voice_client.resume()
        await ctx.send("‚ñ∂Ô∏è ƒê√£ ti·∫øp t·ª•c.")
    else:
        await ctx.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o b·ªã t·∫°m d·ª´ng.")

@bot.command(aliases=['s'])
async def stop(ctx):
    """D·ª´ng ph√°t nh·∫°c v√† x√≥a h√†ng ch·ªù"""
    global queue, is_playing, is_looping, force_skip, current_song, current_song_info
    if ctx.voice_client:
        is_playing = False
        is_looping = False
        force_skip = False
        queue.clear()
        current_song = None
        current_song_info = None
        ctx.voice_client.stop()
        await ctx.send("‚èπÔ∏è ƒê√£ d·ª´ng ph√°t v√† x√≥a h√†ng ch·ªù.")
    else:
        await ctx.send("‚ùå Bot kh√¥ng ·ªü trong voice channel.")

@bot.command(aliases=['next', 'n'])
async def skip(ctx):
    """B·ªè qua b√†i h√°t hi·ªán t·∫°i"""
    global force_skip
    if ctx.voice_client and ctx.voice_client.is_playing():
        force_skip = True
        ctx.voice_client.stop()
        await ctx.send("‚è≠Ô∏è ƒê√£ b·ªè qua b√†i h√°t.")
        await asyncio.sleep(1)
        force_skip = False
    else:
        await ctx.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.")

@bot.command()
async def loop(ctx):
    """B·∫≠t/t·∫Øt ch·∫ø ƒë·ªô l·∫∑p l·∫°i b√†i h√°t hi·ªán t·∫°i"""
    global is_looping
    is_looping = not is_looping
    await ctx.send(f"üîÅ Ch·∫ø ƒë·ªô l·∫∑p {'ƒë√£ b·∫≠t' if is_looping else 'ƒë√£ t·∫Øt'}.")

@bot.command(name='queue', aliases=['list', 'q'])
async def show_queue(ctx, page: int = 1):
    """Hi·ªÉn th·ªã danh s√°ch h√†ng ch·ªù - S·ª≠ d·ª•ng: queue [s·ªë_trang]"""
    if not queue:
        embed = discord.Embed(
            title="üìÉ H√†ng ch·ªù",
            description="‚ùå H√†ng ch·ªù tr·ªëng.",
            color=discord.Color.red()
        )
        embed.set_footer(text=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name}", icon_url=ctx.author.avatar.url)
        return await ctx.send(embed=embed)
    
    # T√≠nh to√°n ph√¢n trang
    songs_per_page = 10
    total_pages = math.ceil(len(queue) / songs_per_page)
    
    # Ki·ªÉm tra s·ªë trang h·ª£p l·ªá
    if page < 1:
        page = 1
    elif page > total_pages:
        page = total_pages
    
    start_index = (page - 1) * songs_per_page
    end_index = min(start_index + songs_per_page, len(queue))
    
    embed = discord.Embed(
        title="üìÉ H√†ng ch·ªù nh·∫°c",
        color=discord.Color.blue()
    )
    
    # T·∫°o danh s√°ch c√°c b√†i h√°t trong h√†ng ch·ªù
    queue_list = []
    queue_items = [item for item in queue]  # Convert deque to list
    
    # Strategy m·ªõi: Ch·ªâ l·∫•y title chi ti·∫øt cho 3 b√†i ƒë·∫ßu, c√≤n l·∫°i d√πng query ho·∫∑c cache
    priority_songs = []  # C√°c b√†i ∆∞u ti√™n (3 b√†i ƒë·∫ßu)
    regular_songs = []   # C√°c b√†i c√≤n l·∫°i
    
    for i in range(start_index, end_index):
        _, query = queue_items[i]
        
        if i < 3:  # 3 b√†i ƒë·∫ßu ti√™n - l·∫•y title chi ti·∫øt
            priority_songs.append((i, query))
        else:  # C√°c b√†i c√≤n l·∫°i - d√πng cache ho·∫∑c query g·ªëc
            regular_songs.append((i, query))
    
    # L·∫•y title cho c√°c b√†i ∆∞u ti√™n song song (async)
    priority_titles = {}
    if priority_songs:
        priority_tasks = []
        for i, query in priority_songs:
            task = get_display_title(query, use_cache=True)
            priority_tasks.append((i, task))
        
        # Ch·∫°y song song ƒë·ªÉ gi·∫£m delay
        for i, task in priority_tasks:
            try:
                title = await asyncio.wait_for(task, timeout=2.0)  # Timeout 2s m·ªói b√†i
                priority_titles[i] = title
            except asyncio.TimeoutError:
                # N·∫øu timeout, d√πng cache ho·∫∑c query g·ªëc
                _, query = queue_items[i]
                priority_titles[i] = song_title_cache.get(query, query[:45] + ('...' if len(query) > 45 else ''))
            except:
                _, query = queue_items[i]
                priority_titles[i] = query[:45] + ('...' if len(query) > 45 else '')
    
    # T·∫°o danh s√°ch hi·ªÉn th·ªã
    for i in range(start_index, end_index):
        _, query = queue_items[i]
        
        if i in priority_titles:
            display_title = priority_titles[i]
        else:
            # D√πng cache ho·∫∑c query g·ªëc cho c√°c b√†i kh√¥ng ∆∞u ti√™n
            if query in song_title_cache:
                display_title = song_title_cache[query]
            else:
                display_title = query
        
        # C·∫Øt t√™n b√†i h√°t n·∫øu qu√° d√†i
        if len(display_title) > 45:
            display_title = display_title[:45] + "..."
        
        # Th√™m icon kh√°c nhau cho v·ªã tr√≠
        if i == 0:
            icon = "ü•á"  # B√†i ti·∫øp theo
        elif i == 1:
            icon = "ü•à"
        elif i == 2:
            icon = "ü•â"
        else:
            icon = f"{i + 1}Ô∏è‚É£" if i < 9 else f"`{i + 1}`"
        
        queue_list.append(f"{icon} {display_title}")
    
    if queue_list:
        embed.add_field(
            name=f"üìã Danh s√°ch ({len(queue)} b√†i)",
            value="\n".join(queue_list),
            inline=False
        )
    
    # Th√™m th√¥ng tin th·ªëng k√™
    embed.add_field(
        name="üìä Th·ªëng k√™",
        value=f"```üìù T·ªïng: {len(queue)} b√†i\nüìÑ Trang: {page}/{total_pages}\nüîÅ L·∫∑p: {'B·∫≠t' if is_looping else 'T·∫Øt'}\nüîä √Çm l∆∞·ª£ng: {int(volume_level * 100)}%```",
        inline=True
    )
    
    # Th√™m h∆∞·ªõng d·∫´n
    embed.add_field(
        name="üí° L·ªánh h·ªØu √≠ch",
        value="```‚èØÔ∏è `play/p <t√™n b√†i> - Th√™m b√†i\n‚è≠Ô∏è `skip/next/n - B·ªè qua\n‚è∏Ô∏è `pause - T·∫°m d·ª´ng\nüîÅ `loop - B·∫≠t/t·∫Øt l·∫∑p\n‚èπÔ∏è `stop/s - D·ª´ng h·∫øt```",
        inline=True
    )
    
    embed.set_footer(
        text=f"Y√™u c·∫ßu b·ªüi {ctx.author.display_name} ‚Ä¢ Trang {page}/{total_pages}",
        icon_url=ctx.author.avatar.url
    )
    
    # Th√™m timestamp
    embed.timestamp = ctx.message.created_at
    
    message = await ctx.send(embed=embed)
    
    # Th√™m reaction ƒë·ªÉ chuy·ªÉn trang n·∫øu c√≥ nhi·ªÅu trang
    if total_pages > 1:
        reactions = []
        if page > 1:
            reactions.append("‚¨ÖÔ∏è")  # Trang tr∆∞·ªõc
        if page < total_pages:
            reactions.append("‚û°Ô∏è")  # Trang sau
        reactions.extend(["üîÑ"])  # Refresh v√† Close
        
        try:
            for reaction in reactions:
                await message.add_reaction(reaction)
        except Exception as e:
            print(f"Error adding reactions: {e}")
        
        # T·∫°o listener cho reaction
        def check(reaction, user):
            return (user == ctx.author and 
                   str(reaction.emoji) in ["‚¨ÖÔ∏è", "‚û°Ô∏è", "üîÑ"] and 
                   reaction.message.id == message.id)
        
        try:
            while True:
                reaction, user = await bot.wait_for('reaction_add', timeout=60.0, check=check)
                
                if str(reaction.emoji) == "‚¨ÖÔ∏è" and page > 1:
                    # Chuy·ªÉn trang tr∆∞·ªõc
                    new_page = page - 1
                    await message.delete()
                    await show_queue(ctx, new_page)
                    break
                    
                elif str(reaction.emoji) == "‚û°Ô∏è" and page < total_pages:
                    # Chuy·ªÉn trang sau
                    new_page = page + 1
                    await message.delete()
                    await show_queue(ctx, new_page)
                    break
                    
                elif str(reaction.emoji) == "üîÑ":
                    # Refresh trang hi·ªán t·∫°i
                    await message.delete()
                    await show_queue(ctx, page)
                    break
                    

                
                # X√≥a reaction c·ªßa user ƒë·ªÉ h·ªç c√≥ th·ªÉ click l·∫°i
                await message.remove_reaction(reaction.emoji, user)
                
        except asyncio.TimeoutError:
            # X√≥a t·∫•t c·∫£ reaction sau 60 gi√¢y
            try:
                await message.clear_reactions()
            except:
                pass

@bot.command(name='queuenext', aliases=['qn'])
async def queue_next_page(ctx):
    """Chuy·ªÉn sang trang ti·∫øp theo c·ªßa h√†ng ch·ªù"""
    if not queue:
        return await ctx.send("‚ùå H√†ng ch·ªù tr·ªëng.")
    
    songs_per_page = 10
    total_pages = math.ceil(len(queue) / songs_per_page)
    
    # M·∫∑c ƒë·ªãnh chuy·ªÉn sang trang 2
    await show_queue(ctx, 2)

@bot.command(name='queueprev', aliases=['qp'])
async def queue_prev_page(ctx):
    """Chuy·ªÉn v·ªÅ trang ƒë·∫ßu c·ªßa h√†ng ch·ªù"""
    if not queue:
        return await ctx.send("‚ùå H√†ng ch·ªù tr·ªëng.")
    
    # Chuy·ªÉn v·ªÅ trang 1
    await show_queue(ctx, 1)

@bot.command()
async def volume(ctx, level: float = None):
    """ƒêi·ªÅu ch·ªânh √¢m l∆∞·ª£ng (0.0-2.0)"""
    global volume_level, current_player
    
    if level is None:
        return await ctx.send(f"üîä √Çm l∆∞·ª£ng hi·ªán t·∫°i: {int(volume_level * 100)}%")
    
    if 0.0 <= level <= 2.0:
        volume_level = level
        if current_player:
            current_player.volume = volume_level
        await ctx.send(f"üîä ƒê√£ ƒë·∫∑t √¢m l∆∞·ª£ng: {int(volume_level * 100)}%")
    else:
        await ctx.send("‚ùå √Çm l∆∞·ª£ng ph·∫£i t·ª´ 0.0 ƒë·∫øn 2.0 (0% ƒë·∫øn 200%)")

@bot.command()
async def now(ctx):
    """Hi·ªÉn th·ªã b√†i h√°t ƒëang ph√°t"""
    if current_song and current_song_info:
        title = current_song_info['title']
        duration_str = format_duration(current_song_info['duration'])
        webpage_url = current_song_info['webpage_url']
        
        embed = discord.Embed(
            title="üé∂ ƒêang ph√°t",
            description=f"[{title}]({webpage_url})",
            color=discord.Color.blue()
        )
        embed.add_field(name="‚è≥ Th·ªùi l∆∞·ª£ng", value=duration_str, inline=True)
        embed.add_field(name="üîä √Çm l∆∞·ª£ng", value=f"{int(volume_level * 100)}%", inline=True)
        embed.add_field(name="üîÅ L·∫∑p", value="B·∫≠t" if is_looping else "T·∫Øt", inline=True)
        
        # Th√™m footer v·ªõi ng∆∞·ªùi y√™u c·∫ßu
        if current_song:
            requester_ctx, _ = current_song
            embed.set_footer(text=f"Y√™u c·∫ßu b·ªüi {requester_ctx.author.display_name}", icon_url=requester_ctx.author.avatar.url)
        
        await ctx.send(embed=embed)
    else:
        await ctx.send("‚ùå Kh√¥ng c√≥ b√†i h√°t n√†o ƒëang ph√°t.")

@bot.command()
async def clearcache(ctx):
    """X√≥a cache t√™n b√†i h√°t ƒë·ªÉ l√†m m·ªõi"""
    global song_title_cache
    song_title_cache.clear()
    await ctx.send("üóëÔ∏è ƒê√£ x√≥a cache t√™n b√†i h√°t.")

@bot.command()
async def speak(ctx, *, message: str):
    """ƒê·ªçc vƒÉn b·∫£n b·∫±ng gi·ªçng n√≥i"""
    if not ctx.author.voice:
        return await ctx.send("‚ùå B·∫°n c·∫ßn v√†o voice channel tr∆∞·ªõc.")
    
    vc = ctx.voice_client
    if not vc:
        vc = await ctx.author.voice.channel.connect()
    
    tts = gTTS(text=message, lang='vi')
    tts.save("tts.mp3")
    
    if vc.is_playing():
        vc.stop()
    
    vc.play(discord.FFmpegPCMAudio("tts.mp3"))
    await ctx.send(f"üó£Ô∏è ƒêang ƒë·ªçc: `{message}`")
    
    await asyncio.sleep(1)
    if os.path.exists("tts.mp3"):
        os.remove("tts.mp3")

@bot.event
async def on_message(message):
    if message.author == bot.user:
        return

    if "hi·∫øu" in message.content.lower():
        await message.channel.send("Em c·∫£m ∆°n anh Hi·∫øu nhi·ªÅu nh√°a")
        
    if "c√°o" in message.content.lower():
        await message.channel.send("Em c·∫£m ∆°n anh C√°o ƒë√£ gi√∫p em ·∫°a")
        
    

    await bot.process_commands(message)

  

# L·∫•y Discord token t·ª´ environment variable
DISCORD_TOKEN = os.getenv('DISCORD_TOKEN')

if not DISCORD_TOKEN:
    print("‚ùå DISCORD_TOKEN kh√¥ng ƒë∆∞·ª£c t√¨m th·∫•y trong .env file!")
    print("Vui l√≤ng th√™m DISCORD_TOKEN v√†o file .env")
    exit(1)

# Ch·∫°y bot
try:
    bot.run(DISCORD_TOKEN)
except discord.LoginFailure:
    print("‚ùå Discord token kh√¥ng h·ª£p l·ªá!")
except Exception as e:
    print(f"‚ùå L·ªói khi ch·∫°y bot: {e}")